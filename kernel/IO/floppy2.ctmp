#include "floppy.h"

#define STATUS_REGISTER_A                0x3F0 // read-only
#define STATUS_REGISTER_B                0x3F1 // read-only
#define DIGITAL_OUTPUT_REGISTER          0x3F2
#define TAPE_DRIVE_REGISTER              0x3F3
#define MAIN_STATUS_REGISTER             0x3F4 // read-only
#define DATARATE_SELECT_REGISTER         0x3F4 // write-only
#define DATA_FIFO                        0x3F5
#define DIGITAL_INPUT_REGISTER           0x3F7 // read-only
#define CONFIGURATION_CONTROL_REGISTER   0x3F7  // write-only

void floppy_start_motor(char floppy_id)
{
	char floppy_DOR;
	if(floppy_id == 0)
		// handles floppy 0
		floppy_DOR = 0x1C;
	else
		// handle only floppy 1
		floppy_DOR = 0x1C;

	floppy_DOR = 0x1C;
	outb(floppy_DOR, DIGITAL_OUTPUT_REGISTER); // spin the selected motor 
}

void floppy_stop_motor(char floppy_id)
{
	char floppy_DOR = 0x0C;

	outb(floppy_DOR, DIGITAL_OUTPUT_REGISTER); // spin the selected motor 
}

void floppy_waitready()
{
	char msr;
	do{
		msr = inb(MAIN_STATUS_REGISTER);
	}while(msr & 0x1F);
	
	return;
}

static const char *floppy_drive_types[] = 
{
	"no drive", "360KB 5.25\"", "1.2MB 5.25\"", "720KB 3.5\"", "1.44MB 3.5\"", "2.88MB 3.5\"" 
};



void print_floppy_drives()
{
	char flp0 = read_floppies();
	char flp1 = flp0 & 0x0F;
	flp0 = (flp0 & 0xF0) >> 4;
	prints("floppy 0 : ");
	prints(floppy_drive_types[flp0]);
	prints("\nfloppy 1 : ");
	prints(floppy_drive_types[flp1]);
	printc('\n');

	// read MAIN_STATUS_REGISTER
	char msr = inb(MAIN_STATUS_REGISTER);
	if(msr & 0x80)
		prints("Floppy exchange on FIFO port\n");
	else
		prints("Floppy no FIFO port exchange\n");

	if(msr & 0x40)
		prints("Floppy expects IN FIFO opcode\n");
	else
		prints("Floppy doesn't expects IN FIFO opcode\n");

	if(msr & 0x10)
		prints("Drive busy\n");
	else
		prints("Drive idle\n");

	if(msr & 0x08)
		prints("Drive 3 seeking\n");
	if(msr & 0x04)
		prints("Drive 2 seeking\n");
	if(msr & 0x02)
		prints("Drive 1 seeking\n");
	if(msr & 0x01)
		prints("Drive 0 seeking\n");
}

unsigned char floppy_interrupt;

void floppy_irq_handler()
{
	prints("Floppy interruption occured\n");
	floppy_interrupt = 1;
}

void floppy_reset()
{
	// resets floppy drive 0
	// set reset state in DOR register 
	outb(0x00, DIGITAL_OUTPUT_REGISTER);

	// wait for the interrupt generated by reset
	floppy_interrupt = 0;

	// leave reset state 
	outb(0x0c, DIGITAL_OUTPUT_REGISTER);

	while(!floppy_interrupt);



	// issue 5 sense interrupts 
	// read 5 times a sense interrupt's result because shitty hardware 
	int i;
	for(i=0; i<5; i++)
	{
		outb(0x08, DATA_FIFO);
		char tmp = inb(DATA_FIFO);
		tmp = inb(DATA_FIFO);
	}

	prints("Floppy interrupt : drive reset stage 1.\n");


	// set data rate 
	outb(0x00, DATARATE_SELECT_REGISTER); // 500 Ko/s

	// specify
	// specify 
	outb(0x3, DATA_FIFO);
	// some speeds and random stuff
	outb(0xdf, DATA_FIFO);
	outb(0x03, DATA_FIFO);

	// clear disk change status 
	// motoron
	floppy_start_motor(0);
	timer_wait(1000);
	prints("motor started\n");
	// seek
	floppy_seek(0, 0);
	prints("seek ok\n");
	// recal
	floppy_recalibrate();

	prints("Driver reset\n");	

	// ********************************************* config ******************
	// configure
	// onfigure command = 0x13
	// First parameter byte = 0
	// Second parameter byte = (implied seek ENable << 6) | (fifo DISable << 5) | (drive polling mode DISable << 4) | thresh_val (= threshold - 1)
	// Third parameter byte = precomp_val = 0
	// // No result bytes.
	// // No interrupt.
	// outb(0x13, DATA_FIFO);
	// outb(0, DATA_FIFO);
	// outb(0x58, DATA_FIFO);
	// outb(0x00, DATA_FIFO);
	// prints("Configuration done\n");



	// floppy_interrupt = 0;
	
	// // wait some time for it to reset
	// // timer_wait(200);
	// // reenter normale mode : set reset flag, enable IRQ and DMA 1100
	// outb(0x1c, DIGITAL_OUTPUT_REGISTER);

	// // wait for the interrupt to come 
	// while(!floppy_interrupt);

	// prints("Floppy reset interrupt\n");

	

	// // /* Configure CCR */
	// outb(0x00, CONFIGURATION_CONTROL_REGISTER);

	// /* Now issue a specify */
	//  // fd_command(0xdf);  // SRT = 3ms, HUT = 240ms 
 //  // fd_command(0x02);  // HLT = 16ms, ND = 0
	// // specify 
	// outb(0x3, DATA_FIFO);
	// // some speeds and random stuff
	// outb(0xdf, DATA_FIFO);
	// outb(0x02, DATA_FIFO);

	// prints("Floppy drive reset\n");
}


void floppy_init()
{
	floppy_reset();
	if(!floppy_versioncheck())
		prints("Controler version not supported\n");

	// configure 
	outb(0x13, DATA_FIFO);
	outb(0, DATA_FIFO);
	outb(0x18, DATA_FIFO);
	outb(0x00, DATA_FIFO);
}

void floppy_read()
{
	floppy_init();

	// /* do a recalibration */
	// floppy_interrupt = 0;
	// outb(0x07, DATA_FIFO);
	// outb(0x00, DATA_FIFO);

	// /* Wait interrupt */
	// floppy_interrupt = 0;
	// while(!floppy_interrupt);

	// // after a recal command, send a sensei
	// outb(0x08, DATA_FIFO);
	// unsigned char result = inb(DATA_FIFO);	// whatever
	// result = inb(DATA_FIFO);	// controlers cyl position ( gets if successfull )

	// prints("Floppy recalibrated\n");

	// floppy_interrupt = 0;

	// floppy_seek(0,0);	

	// // timer_wait(500);

	// while(!floppy_interrupt);

	// // after a recal command, send a sensei
	// outb(0x08, DATA_FIFO);
	// result = inb(DATA_FIFO);	// whatever
	// result = inb(DATA_FIFO);	// controlers cyl position ( gets if successfull )

	// prints("About to read data\n");
	// timer_wait(3000);

	floppy_interrupt = 0;

	/* Send read interrupt */
	outb(0xC6, DATA_FIFO);
	 // now send read data, wait for interrupt and then read FIFO 
	outb(((/*head*/0 << 2) | /*fd->drive*/ 0),DATA_FIFO);
	outb(/*track*/0,DATA_FIFO);
	outb(/*head*/0,DATA_FIFO);
	outb(/*sector*/1,DATA_FIFO);
	outb(/* bytes / sector */0x02,DATA_FIFO);
	outb(/* sector count to transfer */ 1,DATA_FIFO);	
	outb(/*gap3*/0x1B, DATA_FIFO);
	outb(/*unused*/0xff, DATA_FIFO);

	while(!floppy_interrupt);

	prints("Floppy read complete\n");

	char st0 = inb(DATA_FIFO);
	char st1 = inb(DATA_FIFO);
	char st2 = inb(DATA_FIFO);
	char cyl = inb(DATA_FIFO);
	char end_head = inb(DATA_FIFO);
	char end_sector = inb(DATA_FIFO);
	char byte2 = inb(DATA_FIFO);

	prints("st0 : "); printi(st0);
	prints("\nst1 : "); printi(st1);
	prints("\nst2 : "); printi(st2);
	prints("\ncyl : "); printi(cyl);
	prints("\nend head : "); printi(end_head);
	prints("\nend_sector : "); printi(end_sector);
	prints("\nbyte2 : "); printi(byte2);
	printc('\n');


	int i;
	for(i=0;i<9;i++)
	{
		unsigned char data = inb(DATA_FIFO);
		printi(data);
	}
	printc('\n');

	// // print_floppy_drives();
	// floppy_init();

	// /* Check MSR for DIO flag : FIFO waits for IN data */
	// char msr = inb(MAIN_STATUS_REGISTER);
	// if(msr & 0x40)
	// 	prints("FIFO waiting for input data...\n");
	// else
	// 	prints("Floppy init complete.\n");

	// floppy_seek(0, 0);

	// floppy_waitready();
	// // struct fdgeometry geom144 = {"3 1/2\" 1.44M", 2, 80, 18, 0x1B};

	// /* Issue read commad */
	// outb(0xE6, DATA_FIFO);
	// /* Send head and drive head         drive */
	// outb((unsigned char) ((0x00 << 2) | 0x00), DATA_FIFO);
	// /* send track */
	// outb((unsigned char) 0x00, DATA_FIFO);
	//  send sector 
	// outb((unsigned char) 0x01, DATA_FIFO);
	// /* Send bytes per sector */
	// outb((unsigned char) 0x02, DATA_FIFO); // 0x02 = 512 bytes per sector 
	// /* Send sector per tracks */
	// outb((unsigned char) 18, DATA_FIFO);
	// /* Send gap3 */
	// outb((unsigned char) 0x1B, DATA_FIFO);
	// /* Send unsued 0xff */
	// outb((unsigned char) 0xff, DATA_FIFO);

	// msr = inb(MAIN_STATUS_REGISTER);
	// if(msr & 0x40)
	// 	prints("Still waiting for data\n");

	// /* Now wait for it to complete (IRQ6) */
	// prints("Waiting for read completion\n");
	// floppy_waitready();
	// prints("Data read complete\n");
}

int floppy_changed()
{
	char dir = inb(DIGITAL_INPUT_REGISTER);
	return (dir & 0x80)? 1 : 0;
}

void floppy_seek(unsigned char track, unsigned char head)
{
	floppy_interrupt = 0;

	/* Send seek command into FIFO register */
	outb(0x0F, DATA_FIFO);
	/* Send drive id and head */
	outb((unsigned char) ((head << 2) | 0x00), DATA_FIFO);
	/* Send track to seek */
	outb(track, DATA_FIFO);

	while(!floppy_interrupt);

	prints("seek semi-complete\n");

	// after a seek command, send a sensei
	outb(0x08, DATA_FIFO);
	unsigned char result = inb(DATA_FIFO);	// whatever
	result = inb(DATA_FIFO);	// controlers cyl position ( gets if successfull )
	prints("Current cylinder : ");
	printi(result);
	prints("\n");
}

void floppy_recalibrate()
{
	floppy_interrupt = 0;
	/* recal command  */
	outb(0x07, DATA_FIFO);
	/* Send drive id  */
	outb(0x00, DATA_FIFO);

	// wait interrupt 
	while(!floppy_interrupt);

	// after a recal command, send a sensei
	outb(0x08, DATA_FIFO);
	unsigned char result = inb(DATA_FIFO);	// whatever
	result = inb(DATA_FIFO);	// controlers cyl position ( gets if successfull )
	prints("recalibrated\n");
}

int floppy_versioncheck()
{
	/* Read controler version */
	// /*Version check */
	outb(0x10, DATA_FIFO);

	/* Read result value */
	unsigned char version_check = inb(DATA_FIFO);

	if(version_check == 0x90)
	{
		prints("Version check OK.\n");
		return 1;
	}
	else
	{
		prints("Version check failed\n");
		return 0;
	}
}